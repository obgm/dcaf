/*
 * Created by Sara Stadler 2018/2019
 */

#ifndef _DCAF_DCAF_ABC_H_
#define _DCAF_DCAF_ABC_H_ 1


#ifdef __cplusplus
extern "C" {
#ifdef EMACS_NEEDS_A_CLOSING_BRACKET
}
#endif
#endif

#include <inttypes.h>
#include "dcaf/dcaf_int.h"
#include "dcaf/utlist.h"

#define DCAF_CREDEDITAL_MAX_BUF_SIZE 8192
#define DCAF_PROOF_MAX_BUF_SIZE 8192

#define DCAF_MAX_PATH_LENGTH DCAF_MAX_STRING

/**
 * Represents a string.
 */
typedef struct str_st{
	char *val;
	unsigned int len;
}str_st;


/**
 * Represents the issuer of an attribute-based credential.
 */
typedef struct issuer_st{
	uint64_t id;
	char *public_key;
	int public_key_path_length;
	int public_key_length;
}issuer_st;

/**
 * Represents an attribute in an attribute-based credential.
 */
typedef struct attribute_st{
	int id;
	long long value;
}attribute_st;

/** A list of attribute_st */
typedef struct attribute_list_st {
  struct attribute_list_st *next;
  attribute_st attribute;
} attribute_list_st;

/**
 * Relates a particular type of credential to an issuer_st.
 */
typedef struct credential_st{
	uint64_t id;
	issuer_st *issuer;
}credential_st;

/** A list of credential_st*/
typedef struct credential_list_st {
  struct credential_list_st *next;
  credential_st credential;
} credential_list_st;


/**
 * Relates a particular type of credential to a storage part
 */
typedef struct credential_location_st{
	uint64_t id;
	char path[DCAF_MAX_PATH_LENGTH + 1];
	int path_length;
}credential_location_st;

/** A list of credential_location_st */
typedef struct credential_store_st {
  struct credential_store_st *next;
  credential_location_st credential_location;
} credential_store_st;

str_st *
dcaf_new_str(int len);
void
dcaf_delete_str(str_st *s);

void
dcaf_delete_issuer(issuer_st *issuer);

attribute_list_st *
dcaf_new_attribute_list(void);
void
dcaf_delete_attribute_list(attribute_list_st *a);

credential_list_st *
dcaf_new_credential_list(void);
void
dcaf_delete_credential_list(credential_list_st *c);

credential_store_st *
dcaf_new_credential_store(void);
void
dcaf_delete_credential_store(credential_store_st *c);


/**
 * Searches the @p credenential_list for the @p credential_id.
 * @return The issuer_st for the credential type with the given id if present,
 * NULL otherwise
 * @param credential_list the credential list to search
 * @param credential_id the credential id to search for
 */
issuer_st *find_issuer_by_credential_id(credential_list_st *credential_list, uint64_t credential_id);

/*
 * Determines the nonce length required for disclosure proofs on the
 * credential type with given id.
 * @return The required nonce length if it can be determined; 0 in case of error.
 * @param credential_list the credential list to search
 * @param credential_id The id identifying the credential type.
 */
int get_required_nonce_length_by_credential(credential_list_st *credential_list, uint64_t credential_id);

/**
 * Searches the @p credential_store for the @p credential_id.
 * @return The path to the file containing the credential with the given id if present,
 * NULL otherwise.
 * @param credential_store the credential store to search
 * @param credential_id the credential id to search for
 */
char *find_credential_path_by_id(credential_store_st *credential_store, uint64_t credential_id);

/**
 * Initializes the configuration for the operations based on attribute
 * based credentials.
 * @return DCAF_OK if the configuration is initialized.
 * @param abc_binary_path path to the binary
 * @param fifo_path the path to the fifo where the binaries output is written to
 */
dcaf_result_t init_abc_configuration(const char *abc_binary_path, const char *fifo_path);

/**
 * Constructs and executes the command to generate a
 * selective disclosure proof on an attribute-based credential.
 * On success the function allocates memory for proof that has to be
 * freed by calling dcaf_delete_str().
 * @return DCAF_OK on success an DCAF_ERROR_INTERNAL_ERROR on error.
 * @param credential_file path to the file containing the credential
 * @param public_key_file path to the file containing the credential issuer's public key
 * @param n1 a random nonce send by the verifier in the attribute info message
 * @param attributes the attributes to be revealed as binary flag.
 * If flag is set to 0 an empty proof is generated.
 * @param proof pointer to the proof generated by this function
 */
dcaf_result_t generate_proof(const char *credential_file, const char *public_key_file, dcaf_nonce_t  *n1, int attributes, str_st **proof);

/**
 * Constructs and executes the command to verify a
 * selective disclosure proof on an attribute-based credential.
 * @return DCAF_OK on success, DCAF_ERROR_INTERNAL_ERROR on error and DCAF_ERROR_UNAUTHORIZED if the proof is not valid.
 * @param public_key_file path to the file containing the credential issuer's public key
 * @param n1 a random nonce send by the verifier in the attribute info message
 * @param proof the proof to verify
 */
dcaf_result_t verify_proof(const char *public_key_file, dcaf_nonce_t  *n1, str_st *proof);


#ifdef __cplusplus
}
#endif

#endif /* INCLUDE_DCAF_DCAF_ABC_H_ */
